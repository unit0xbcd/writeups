
## Challenge Description

* Rustline <em>(medium)</em>

Author: @HuskyHacks<br><br>Jerry: A Redline Stealer. <br> George: Written in Rust. <br> Jerry: A Rusty Redline Stealer. <br> George: A Rusty Redline Stealer, Jerry! <br><br> We caught a Redline variant executing on an endpoint and intercepted the encrypted files as they traversed the edge proxy. Well, everything except for the flag.txt file (imagine that...). Any chance you could figure out how this thing works and recover the flag?<br>

## Solution

Rustline emulates a simple ransomware scenario. We were provided an archive containing two folders. One held a set of files in plaintext, the other held the same files encrypted and an additional encrypted file - containing the flag.

![screenshot](rustline00.png)

We were also provided a Windows executable that contained our malware and could potentially be reverse engineered to determine how the files were encrypted. I had come along quite late in the day and the challenge already had a few solves - and the first in only three minutes. The binary was large and complex so my instinct told me it was not solved this way.

On examining the files this looked correct. We had plenty of plaintext / ciphertext pairs to do analysis on and there was a reasonable chance the solve was a simple xor of the plaintext with a key. First I set about proving this to see if I was on the right track.

I examined one of the RSA private keys, since I know the file format well. This was a lucky choice.

![screenshot](rustline01.png)

The first line of a private key contains the text '-----BEGIN OPENSSH PRIVATE KEY-----'. Examining the hex output of both files shows us that the first three dashes of the message on the encrypted file are '95 da 02' compared to '2d 2d 2d' on the plaintext. This pattern then repeats for the last three dashes. This indicates our key length is short and repeats at least once in this length of the message.

Since xor is a reversible operation, if we xor the two files together we should be able to see the key and determine where it starts repeating.

```python
from sys import argv

with open(argv[1], 'rb') as plaintext, open(argv[2], 'rb') as ciphertext:

	plain = plaintext.read()
	cipher = ciphertext.read()
	key = bytearray()

	for el in range(len(plain)):
		key.append(plain[el] ^ cipher[el])

print(key.hex())
```

```
unit0xbcd@darkstar:$ python3 key.py challenge-files/id_rsa_aws_ec2 encrypted-files/id_rsa_aws_ec2
b8f72ff695587745b08fdc8ee71adf7eb8f72ff695587745b08fdc8ee71adf7eb8f72ff695587745b08fdc8ee71adf7e
b8f72ff695587745b08fdc8ee71adf7eb8f72ff695587745b08fdc8ee71adf7eb8f72ff695587745b08fdc8ee71adf7e
b8f72ff695587745b08fdc8ee71adf7eb8f72ff695587745b08fdc8ee71adf7eb8f72ff695587745b08fdc8ee71adf7e
```

A little bit of python and we find the key: `b8f72ff695587745b08fdc8ee71adf7e`. Now I just needed to decrypt the flag.

I ended up stuck here for a little while - I knew I was on the right track, since using an online calculator to test my discovered key on a test bit of ciphertext the same length gave me an expected portion of a plaintext message.

```
b8 f7 2f f6 95 58 77 45 b0 8f dc 8e e7 1a df 7e - key

95 da 02 db b8 1a 32 02 f9 c1 fc c1 b7 5f 91 2d - ciphertext

2d 2d 2d 2d 2d 42 45 47 49 4e 20 4f 50 45 4e 53 - plaintext

-  -  -  -  -  B  E  G  I  N     O  P  E  N  S  - ascii 
```

Try as I might though, I could not replicate the results from the online calculator. I stared at the calculator for a while, puzzled ... then looked at it more closely and it clicked.

![screenshot](rustline02.png)

"Non-binary inputs are converted into their binary equivalents using gmp_init"

I had assumed I needed to xor the data byte by byte - a streaming approach repeating the key as needed until the operation was complete. The online calculator was giving me the correct answer on my test snippet because it converts both values to a binary integer and does an xor on the whole. With quite a few iterations for mistakes I modified my python to do the same and hey presto - flag.

```python
from sys import argv

key = 'b8f72ff695587745b08fdc8ee71adf7e'
byteskey = bytes.fromhex(key)

with open(argv[1], 'rb') as ciphertext:

	cipher = ciphertext.read()
	keyblock = (byteskey * (len(cipher) // len(byteskey) + 1) [:len(cipher)]

	intcipher = int(cipher.hex(), 16)
	intkey = int(keyblock.hex() , 16)

	intflag = intcipher ^ intkey

	hexflag = hex(intflag)[2:]

	flag = bytes.fromhex(hexflag).decode()

	print(flag)
```


`unit0xbcd@darkstar:$ python3 please-god.py flag.txt`

"Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt. Neque porro quisquam est, qui dolorem ipsum quia dolor sit amet, consectetur, adipisci velit, sed quia non numquam eius modi tempora incidunt ut labore et dolore magnam aliquam quaerat voluptatem. Ut enim ad minima veniam, quis nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut aliquid ex ea commodi consequatur? Quis autem vel eum iure reprehenderit qui in ea voluptate velit esse quam nihil molestiae consequatur, vel illum qui dolorem eum fugiat quo voluptas nulla pariatur?"

flag{bfe12aadd139def4d47f5f51a539249d}

"Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt. Neque porro quisquam est, qui dolorem ipsum quia dolor sit amet, consectetur, adipisci velit, sed quia non numquam eius modi tempora incidunt ut labore et dolore magnam aliquam quaerat voluptatem. Ut enim ad minima veniam, quis nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut aliquid ex ea commodi consequatur? Quis autem vel eum iure reprehenderit qui in ea voluptate velit esse quam nihil molestiae consequatur, vel illum qui dolorem eum fugiat quo voluptas nulla pariatur?"





